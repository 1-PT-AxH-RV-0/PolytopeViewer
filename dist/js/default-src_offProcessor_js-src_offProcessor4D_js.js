"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["default-src_offProcessor_js-src_offProcessor4D_js"],{

/***/ "./src/helperFunc.js":
/*!***************************!*\
  !*** ./src/helperFunc.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   apply4DInverseRotation: () => (/* binding */ apply4DInverseRotation),\n/* harmony export */   apply4DMatrix: () => (/* binding */ apply4DMatrix),\n/* harmony export */   are4DPointsClose: () => (/* binding */ are4DPointsClose),\n/* harmony export */   arePointsClose: () => (/* binding */ arePointsClose),\n/* harmony export */   changeMaterialProperty: () => (/* binding */ changeMaterialProperty),\n/* harmony export */   create4DRotationMat: () => (/* binding */ create4DRotationMat),\n/* harmony export */   decomposeSelfIntersectingPolygon: () => (/* binding */ decomposeSelfIntersectingPolygon),\n/* harmony export */   disposeGroup: () => (/* binding */ disposeGroup),\n/* harmony export */   getFarthest4DPointDist: () => (/* binding */ getFarthest4DPointDist),\n/* harmony export */   getFarthestPointDist: () => (/* binding */ getFarthestPointDist),\n/* harmony export */   getSortedValuesDesc: () => (/* binding */ getSortedValuesDesc),\n/* harmony export */   getUniqueSortedPairs: () => (/* binding */ getUniqueSortedPairs),\n/* harmony export */   inverseRotatePoint: () => (/* binding */ inverseRotatePoint),\n/* harmony export */   parseJsonFileFromInput: () => (/* binding */ parseJsonFileFromInput),\n/* harmony export */   range: () => (/* binding */ range),\n/* harmony export */   rotate4DPointsToXY: () => (/* binding */ rotate4DPointsToXY),\n/* harmony export */   rotateToXY: () => (/* binding */ rotateToXY),\n/* harmony export */   toBufferGeometry: () => (/* binding */ toBufferGeometry),\n/* harmony export */   validateRecordConfig: () => (/* binding */ validateRecordConfig)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.core.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash */ \"./node_modules/lodash/lodash.js\");\n/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var poly2tri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! poly2tri */ \"./node_modules/poly2tri/src/poly2tri.js\");\n/* harmony import */ var poly2tri__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(poly2tri__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var polygon_clipping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! polygon-clipping */ \"./node_modules/polygon-clipping/dist/polygon-clipping.umd.js\");\n/* harmony import */ var polygon_clipping__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(polygon_clipping__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./type.js */ \"./src/type.js\");\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\n\n\n\n\n\n\n\n/**\n * 将自相交多边形分解为多个非自相交多边形。\n * @param {Array<{x: number, y: number}>} originalPoints - 原始多边形点集。\n * @returns {Array<Array<poly2tri.Point>>} 分解后的多边形数组。\n */\nfunction decomposeSelfIntersectingPolygon(originalPoints) {\n  var coords = originalPoints.map(function (p) {\n    return [+p.x.toFixed(6), +p.y.toFixed(6)];\n  });\n  if (coords.length > 0) {\n    coords.push([coords[0][0], coords[0][1]]);\n  }\n  var result = polygon_clipping__WEBPACK_IMPORTED_MODULE_2__.union([coords]);\n  var decomposed = [];\n  var _iterator = _createForOfIteratorHelper(result),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var polygon = _step.value;\n      var _iterator2 = _createForOfIteratorHelper(polygon),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var ring = _step2.value;\n          if (ring.length === 0) continue;\n          var ringPoints = ring.slice(0, -1);\n          var points = ringPoints.map(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n              x = _ref2[0],\n              y = _ref2[1];\n            return new poly2tri__WEBPACK_IMPORTED_MODULE_1__.Point(x, y);\n          });\n          decomposed.push(points);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return decomposed;\n}\n\n/**\n * 计算 3D 点集所在平面的法向量。\n * @param {Array<type.Point3D>} points - 3D 点集。\n * @returns {type.Point3D} 单位法向量。\n */\nfunction computeNormal(points) {\n  var v1 = {\n    x: points[1].x - points[0].x,\n    y: points[1].y - points[0].y,\n    z: points[1].z - points[0].z\n  };\n  var v2 = {\n    x: points[2].x - points[0].x,\n    y: points[2].y - points[0].y,\n    z: points[2].z - points[0].z\n  };\n  var nx = v1.y * v2.z - v1.z * v2.y;\n  var ny = v1.z * v2.x - v1.x * v2.z;\n  var nz = v1.x * v2.y - v1.y * v2.x;\n  var length = Math.sqrt(nx ** 2 + ny ** 2 + nz ** 2);\n  return {\n    x: nx / length,\n    y: ny / length,\n    z: nz / length\n  };\n}\n\n/**\n * 按照给定的 theta 和 phi 角度旋转 3D 点。\n * @param {type.Point3D} p - 要旋转的点。\n * @param {number} theta - 绕 X 轴的旋转角度（弧度）。\n * @param {number} phi - 绕 Y 轴的旋转角度（弧度）。\n * @returns {{x: number, y: number, z: number, orig: object}} 旋转后的点，包含原始点引用。\n */\nfunction rotatePoint(p, theta, phi) {\n  var cosT = Math.cos(theta),\n    sinT = Math.sin(theta);\n  var cosP = Math.cos(phi),\n    sinP = Math.sin(phi);\n  var y1 = p.y * cosT - p.z * sinT;\n  var z1 = p.y * sinT + p.z * cosT;\n  var x2 = p.x * cosP + z1 * sinP;\n  var z2 = -p.x * sinP + z1 * cosP;\n  return {\n    x: x2,\n    y: y1,\n    z: z2,\n    orig: p\n  };\n}\n\n/**\n * 按照给定的 theta 和 phi 角度反向旋转 3D 点。\n * @param {type.Point3D} p - 要反向旋转的点。\n * @param {number} theta - 绕 X 轴的反向旋转角度（弧度）。\n * @param {number} phi - 绕 Y 轴的反向旋转角度（弧度）。\n * @returns {type.Point3D} 反向旋转后的点。\n */\nfunction inverseRotatePoint(p, theta, phi) {\n  var cosT = Math.cos(-theta),\n    sinT = Math.sin(-theta);\n  var cosP = Math.cos(-phi),\n    sinP = Math.sin(-phi);\n  var x1 = p.x * cosP + p.z * sinP;\n  var z1 = -p.x * sinP + p.z * cosP;\n  var y2 = p.y * cosT - z1 * sinT;\n  var z2 = p.y * sinT + z1 * cosT;\n  return {\n    x: x1,\n    y: y2,\n    z: z2\n  };\n}\n\n/**\n * 将点集旋转到 XY 平面。\n * @param {Array<type.Point3D>} points - 要旋转的点集。\n * @returns {{rotated: Array<type.Point3D>, theta: number, phi: number, z: number}} 旋转结果和旋转参数。\n */\nfunction rotateToXY(points) {\n  var normal = computeNormal(points);\n  var theta = Math.atan2(normal.y, normal.z);\n  var phi = Math.atan2(-normal.x, Math.sqrt(normal.y ** 2 + normal.z ** 2));\n  var rotated = points.map(function (p) {\n    return rotatePoint(p, theta, phi);\n  });\n  return {\n    rotated: rotated,\n    theta: theta,\n    phi: phi,\n    z: rotated[0].z\n  };\n}\n\n/**\n * 判断两个 3D 点是否在允许误差范围内接近。\n * @param {type.Point3D} point1 - 第一个点。\n * @param {type.Point3D} point2 - 第二个点。\n * @param {number} [epsilon] - 允许的误差范围。\n * @returns {boolean} 如果点在误差范围内接近则返回 true。\n */\nfunction arePointsClose(point1, point2) {\n  var epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.EPSILON;\n  var dx = Math.abs(point1.x - point2.x);\n  var dy = Math.abs(point1.y - point2.y);\n  var dz = Math.abs(point1.z - point2.z);\n  return dx <= epsilon && dy <= epsilon && dz <= epsilon;\n}\n\n/**\n * 从面数组中提取唯一且排序过的边对。\n * @param {Array<Array<number>>} arrays - 面的索引数组。\n * @returns {Array<type.Edge3D>} 唯一且排序过的边对数组。\n */\nfunction getUniqueSortedPairs(arrays) {\n  var pairs = arrays.flatMap(function (arr) {\n    return arr.map(function (v, i) {\n      return [Math.min(v, arr[(i + 1) % arr.length]), Math.max(v, arr[(i + 1) % arr.length])];\n    });\n  });\n  return _toConsumableArray(new Set(pairs.map(JSON.stringify))).map(JSON.parse);\n}\n\n/**\n * 将 4D 空间中的点集旋转到 XY 平面以便进行后续处理。\n * @param {Array<type.Point4D>} points - 要旋转的 4D 点数组。\n * @returns {{rotated: Array<type.Point4D>, rotationMatrix: type.RotationMatrix, z: number, w: number}} 包含旋转后点集、4x4 旋转矩阵和原始 z/w 值的对象。\n * @throws {Error} 当输入向量太小或线性相关时抛出错误。\n */\nfunction rotate4DPointsToXY(points) {\n  // 1. 提取前三个点\n  var p0 = points[0];\n  var p1 = points[1];\n  var p2 = points[2];\n\n  // 2. 计算向量 u 和 v\n  var u = [p1.x - p0.x, p1.y - p0.y, p1.z - p0.z, p1.w - p0.w];\n  var v = [p2.x - p0.x, p2.y - p0.y, p2.z - p0.z, p2.w - p0.w];\n\n  // 3. 归一化 u 得到  q1\n  var normU = Math.sqrt(u.reduce(function (sum, val) {\n    return sum + val * val;\n  }, 0));\n  if (normU < 1e-10) throw new Error('Vector u is too small.');\n  var q1 = u.map(function (x) {\n    return x / normU;\n  });\n\n  // 4. 计算 v 在 u 上的投影并正交化\n  var dotUV = v.reduce(function (sum, val, i) {\n    return sum + val * u[i];\n  }, 0);\n  var projUV = u.map(function (x) {\n    return dotUV / (normU * normU) * x;\n  });\n  var vOrtho = v.map(function (val, i) {\n    return val - projUV[i];\n  });\n  var normVOrtho = Math.sqrt(vOrtho.reduce(function (sum, val) {\n    return sum + val * val;\n  }, 0));\n  if (normVOrtho < 1e-10) throw new Error('Vectors are linearly dependent.');\n  var q2 = vOrtho.map(function (x) {\n    return x / normVOrtho;\n  });\n\n  // 5. 构造与 q1,q2 正交的基向量\n  var basis = [q1, q2];\n  var orthoVecs = [];\n  var stdBasis = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];\n  var _loop = function _loop() {\n    var e = _stdBasis[_i];\n    var vec = _toConsumableArray(e);\n    var _loop2 = function _loop2() {\n      var b = _basis[_i2];\n      var dot = vec.reduce(function (sum, val, i) {\n        return sum + val * b[i];\n      }, 0);\n      vec = vec.map(function (val, i) {\n        return val - dot * b[i];\n      });\n    };\n    for (var _i2 = 0, _basis = basis; _i2 < _basis.length; _i2++) {\n      _loop2();\n    }\n    var norm = Math.sqrt(vec.reduce(function (sum, val) {\n      return sum + val * val;\n    }, 0));\n    if (norm > 1e-6) {\n      orthoVecs.push(vec.map(function (x) {\n        return x / norm;\n      }));\n      basis.push(vec.map(function (x) {\n        return x / norm;\n      }));\n      if (orthoVecs.length >= 2) return 1; // break\n    }\n  };\n  for (var _i = 0, _stdBasis = stdBasis; _i < _stdBasis.length; _i++) {\n    if (_loop()) break;\n  }\n  if (orthoVecs.length < 2) throw new Error('Failed to find orthogonal basis');\n  var q3 = orthoVecs[0],\n    q4 = orthoVecs[1];\n\n  // 6. 构造旋转矩阵（行向量为 q1, q2, q3, q4）\n  var rotationMatrix = [q1, q2, q3, q4];\n\n  // 7. 应用旋转矩阵\n  var rotatedPoints = points.map(function (p) {\n    return apply4DMatrix(p, rotationMatrix);\n  });\n\n  // 8. 提取结果\n  var firstRotated = rotatedPoints[0];\n  return {\n    rotated: rotatedPoints,\n    rotationMatrix: rotationMatrix,\n    z: firstRotated.z,\n    w: firstRotated.w\n  };\n}\n\n/**\n * 应用 4D 变换矩阵到单个点。\n * @param {type.Point4D} point - 要变换的 4D 点。\n * @param {type.RotationMatrix} matrix - 4D 旋转矩阵。\n * @returns {type.Point4D} 变换后的 4D 点。\n */\nfunction apply4DMatrix(point, matrix) {\n  var vec = [point.x, point.y, point.z, point.w];\n  var transformed = [matrix[0][0] * vec[0] + matrix[0][1] * vec[1] + matrix[0][2] * vec[2] + matrix[0][3] * vec[3], matrix[1][0] * vec[0] + matrix[1][1] * vec[1] + matrix[1][2] * vec[2] + matrix[1][3] * vec[3], matrix[2][0] * vec[0] + matrix[2][1] * vec[1] + matrix[2][2] * vec[2] + matrix[2][3] * vec[3], matrix[3][0] * vec[0] + matrix[3][1] * vec[1] + matrix[3][2] * vec[2] + matrix[3][3] * vec[3]];\n  return {\n    x: transformed[0],\n    y: transformed[1],\n    z: transformed[2],\n    w: transformed[3]\n  };\n}\n\n/**\n * 应用 4D 旋转矩阵的逆变换（转置矩阵）到单个点。\n * @param {type.Point4D} rotatedPoint - 已旋转的点。\n * @param {type.RotationMatrix} rotationMatrix - 原始 4D 旋转矩阵。\n * @returns {type.Point4D} 逆旋转后的 4D 点。\n */\nfunction apply4DInverseRotation(rotatedPoint, rotationMatrix) {\n  // 计算旋转矩阵的逆矩阵。（转置矩阵，因为旋转矩阵是正交矩阵）\n  var inverseRotation = [[rotationMatrix[0][0], rotationMatrix[1][0], rotationMatrix[2][0], rotationMatrix[3][0]], [rotationMatrix[0][1], rotationMatrix[1][1], rotationMatrix[2][1], rotationMatrix[3][1]], [rotationMatrix[0][2], rotationMatrix[1][2], rotationMatrix[2][2], rotationMatrix[3][2]], [rotationMatrix[0][3], rotationMatrix[1][3], rotationMatrix[2][3], rotationMatrix[3][3]]];\n  return apply4DMatrix(rotatedPoint, inverseRotation);\n}\n\n/**\n * 判断两个 4D 点是否在允许误差范围内接近。\n * @param {type.Point4D} point1 - 第一个 4D 点。\n * @param {type.Point4D} point2 - 第二个 4D 点。\n * @param {number} [epsilon] - 允许的误差范围。\n * @returns {boolean} 如果所有坐标差值都在误差范围内则返回 true。\n */\nfunction are4DPointsClose(point1, point2) {\n  var epsilon = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.EPSILON;\n  var dx = Math.abs(point1.x - point2.x);\n  var dy = Math.abs(point1.y - point2.y);\n  var dz = Math.abs(point1.z - point2.z);\n  var dw = Math.abs(point1.w - point2.w);\n  return dx <= epsilon && dy <= epsilon && dz <= epsilon && dw <= epsilon;\n}\n\n/**\n * 生成从 start 到 stop 的连续整数数组。\n * @param {number} start - 起始值（包含）。\n * @param {number} stop - 结束值（包含）。\n * @returns {Array<number>} 生成的整数数组。\n */\nfunction range(start, stop) {\n  var length = Math.max(stop - start + 1, 0);\n  return Array.from({\n    length: length\n  }, function (_, i) {\n    return start + i;\n  });\n}\n\n/**\n * 获取点集中离原点最远的点的距离。\n * @param {Array<type.Point3D>} points - 3D 点集。\n * @returns {number} - 最远点离原点的距离。\n */\nfunction getFarthestPointDist(points) {\n  var getDist = function getDist(p) {\n    return Math.sqrt(p.x ** 2 + p.y ** 2 + p.z ** 2);\n  };\n  return getDist(points.reduce(function (farthest, point) {\n    var dist = point.x ** 2 + point.y ** 2 + point.z ** 2;\n    return dist > (farthest.dist || -1) ? {\n      point: point,\n      dist: dist\n    } : farthest;\n  }, {}).point);\n}\n\n/**\n * 获取 4D 点集中离原点最远的点的距离。\n * @param {Array<type.Point4D>} points - 4D 点集。\n * @returns {number} - 最远点离原点的距离。\n */\nfunction getFarthest4DPointDist(points) {\n  var getDist = function getDist(p) {\n    return Math.sqrt(p.x ** 2 + p.y ** 2 + p.z ** 2 + p.w ** 2);\n  };\n  return getDist(points.reduce(function (farthest, point) {\n    var dist = point.x ** 2 + point.y ** 2 + point.z ** 2 + point.w ** 2;\n    return dist > (farthest.dist || -1) ? {\n      point: point,\n      dist: dist\n    } : farthest;\n  }, {}).point);\n}\n\n/**\n * 修改材质属性\n * @param {THREE.Group} group - 组。\n * @param {string} propertyName - 属性路径。\n * @param { any } newValue - 新值。\n */\nfunction changeMaterialProperty(group, propertyName, newValue) {\n  if (!group) return;\n  group.traverse(function (child) {\n    if (child.isMesh && child.material) {\n      if (!Array.isArray(child.material)) {\n        (0,lodash__WEBPACK_IMPORTED_MODULE_0__.set)(child.material, propertyName, newValue);\n        child.material.needsUpdate = true;\n      } else {\n        var _iterator3 = _createForOfIteratorHelper(child.material),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var material = _step3.value;\n            (0,lodash__WEBPACK_IMPORTED_MODULE_0__.set)(material, propertyName, newValue);\n            material.needsUpdate = true;\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }\n  });\n}\n\n/**\n * 释放组。\n * @param {THREE.Group} group - 组。\n */\nfunction disposeGroup(group) {\n  group.traverse(function (child) {\n    if (child.isMesh) {\n      var _child$geometry, _child$material;\n      (_child$geometry = child.geometry) === null || _child$geometry === void 0 || _child$geometry.dispose();\n      (_child$material = child.material) === null || _child$material === void 0 || _child$material.dispose();\n    }\n  });\n  group.clear();\n}\n\n/**\n * 转换其他 Geomtry 到 BufferGeometry.\n * @param {(THREE.SphereGeometry | THREE.CylinderGeometry | THREE.ConeGeometry | TextGeometry)} source - 非 BufferGeometry 类型的 Gemotry.\n * @returns {THREE.BufferGeometry} - 复制了 position、normal、uv 数据的 BufferGeometry.\n */\nfunction toBufferGeometry(source) {\n  var geo = new three__WEBPACK_IMPORTED_MODULE_4__.BufferGeometry();\n  ['position', 'normal', 'uv'].forEach(function (k) {\n    return source.attributes[k] && geo.setAttribute(k, source.attributes[k].clone());\n  });\n  source.index && geo.setIndex(source.index.clone());\n  source.parameters && (geo.parameters = _objectSpread({}, source.parameters));\n  source.dispose();\n  return geo;\n}\n\n/**\n * 从旋转欧拉角创建 4D 旋转矩阵。（角度制）\n * @param {number} xy_deg - xy 旋转角度。\n * @param {number} xz_deg - xz 旋转角度。\n * @param {number} xw_deg - xw 旋转角度。\n * @param {number} yz_deg - yz 旋转角度。\n * @param {number} yw_deg - yw 旋转角度。\n * @param {number} zw_deg - zw 旋转角度。\n * @returns {THREE.Matrix4} - 4D 旋转矩阵。\n */\nfunction create4DRotationMat(xy_deg, xz_deg, xw_deg, yz_deg, yw_deg, zw_deg) {\n  // 将角度转换为弧度\n  var xy = three__WEBPACK_IMPORTED_MODULE_4__.MathUtils.degToRad(xy_deg);\n  var xz = three__WEBPACK_IMPORTED_MODULE_4__.MathUtils.degToRad(xz_deg);\n  var xw = three__WEBPACK_IMPORTED_MODULE_4__.MathUtils.degToRad(xw_deg);\n  var yz = three__WEBPACK_IMPORTED_MODULE_4__.MathUtils.degToRad(yz_deg);\n  var yw = three__WEBPACK_IMPORTED_MODULE_4__.MathUtils.degToRad(yw_deg);\n  var zw = three__WEBPACK_IMPORTED_MODULE_4__.MathUtils.degToRad(zw_deg);\n\n  /* eslint-disable */\n  // 计算各旋转角度的正弦和余弦\n  var cxy = Math.cos(xy),\n    sxy = Math.sin(xy);\n  var cxz = Math.cos(xz),\n    sxz = Math.sin(xz);\n  var cxw = Math.cos(xw),\n    sxw = Math.sin(xw);\n  var cyz = Math.cos(yz),\n    syz = Math.sin(yz);\n  var cyw = Math.cos(yw),\n    syw = Math.sin(yw);\n  var czw = Math.cos(zw),\n    szw = Math.sin(zw);\n\n  // 初始化六个基本旋转矩阵\n  var Rxy = new three__WEBPACK_IMPORTED_MODULE_4__.Matrix4().set(cxy, -sxy, 0.0, 0.0, sxy, cxy, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n  var Rxz = new three__WEBPACK_IMPORTED_MODULE_4__.Matrix4().set(cxz, 0.0, -sxz, 0.0, 0.0, 1.0, 0.0, 0.0, sxz, 0.0, cxz, 0.0, 0.0, 0.0, 0.0, 1.0);\n  var Rxw = new three__WEBPACK_IMPORTED_MODULE_4__.Matrix4().set(cxw, 0.0, 0.0, -sxw, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, sxw, 0.0, 0.0, cxw);\n  var Ryz = new three__WEBPACK_IMPORTED_MODULE_4__.Matrix4().set(1.0, 0.0, 0.0, 0.0, 0.0, cyz, -syz, 0.0, 0.0, syz, cyz, 0.0, 0.0, 0.0, 0.0, 1.0);\n  var Ryw = new three__WEBPACK_IMPORTED_MODULE_4__.Matrix4().set(1.0, 0.0, 0.0, 0.0, 0.0, cyw, 0.0, -syw, 0.0, 0.0, 1.0, 0.0, 0.0, syw, 0.0, cyw);\n  var Rzw = new three__WEBPACK_IMPORTED_MODULE_4__.Matrix4().set(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, czw, -szw, 0.0, 0.0, szw, czw);\n  /* eslint-enable */\n\n  // 组合所有旋转（顺序会影响最终结果）\n  var result = new three__WEBPACK_IMPORTED_MODULE_4__.Matrix4();\n  result.multiply(Rzw);\n  result.multiply(Ryw);\n  result.multiply(Ryz);\n  result.multiply(Rxw);\n  result.multiply(Rxz);\n  result.multiply(Rxy);\n  return result;\n}\n\n/**\n * 按键的数值大小对对象进行排序，并返回排序后的值数组。\n * @param {object} obj - 要排序的对象。\n * @returns {Array} 排序后的值数组（按 key 从大到小）。\n */\nfunction getSortedValuesDesc(obj) {\n  return Object.entries(obj).sort(function (_ref3, _ref4) {\n    var _ref5 = _slicedToArray(_ref3, 1),\n      keyA = _ref5[0];\n    var _ref6 = _slicedToArray(_ref4, 1),\n      keyB = _ref6[0];\n    return +keyB - +keyA;\n  }).map(function (_ref7) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n      value = _ref8[1];\n    return value;\n  });\n}\n\n/**\n * 校验录制配置对象中以的有效性。\n * @param {object} config - 要验证的配置对象。\n * @param {boolean} is4D - 是否为 4D 模式。\n * @throws {Error} 当任何字段验证失败时抛出错误，包含具体的错误信息。\n */\nfunction validateRecordConfig(config, is4D) {\n  if (config.initialRot !== undefined) {\n    if (!Array.isArray(config.initialRot) || config.initialRot.length !== 6 || config.initialRot.some(function (v) {\n      return typeof v !== 'number';\n    })) {\n      throw new Error('initialRot 字段必须是包含 6 个实数的数组。');\n    }\n  }\n  if (config.initialOfs !== undefined) {\n    if (!Array.isArray(config.initialOfs) || config.initialOfs.length !== 4 || config.initialOfs.some(function (v) {\n      return typeof v !== 'number';\n    })) {\n      throw new Error('initialOfs 字段必须是包含 4 个实数的数组。');\n    }\n  }\n  if (config.initialOfs3 !== undefined) {\n    if (!Array.isArray(config.initialOfs3) || config.initialOfs3.length !== 3 || config.initialOfs3.some(function (v) {\n      return typeof v !== 'number';\n    })) {\n      throw new Error('initialOfs3 字段必须是包含 3 个实数的数组。');\n    }\n  }\n  if (config.initialVerticesEdgesDim !== undefined) {\n    if (typeof config.initialVerticesEdgesDim !== 'number' || config.initialVerticesEdgesDim <= 0) {\n      throw new Error('initialVerticesEdgesDim 字段必须是正实数。');\n    }\n  }\n  if (config.initialProjDist !== undefined) {\n    if (typeof config.initialProjDist !== 'number' || config.initialProjDist <= 0) {\n      throw new Error('initialProjDist 字段必须是正实数。');\n    }\n  }\n  if (config.initialFaceOpacity !== undefined) {\n    if (typeof config.initialFaceOpacity !== 'number' || config.initialFaceOpacity < 0 || config.initialFaceOpacity > 1) {\n      throw new Error('initialFaceOpacity 字段必须是 0~1 之间的实数。');\n    }\n  }\n  if (config.initialVisibilities !== undefined) {\n    var validTargets = ['faces', 'wireframe', 'vertices', 'axes'];\n    for (var _i3 = 0, _Object$entries = Object.entries(config.initialVisibilities); _i3 < _Object$entries.length; _i3++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),\n        target = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n      if (!validTargets.includes(target)) {\n        throw new Error(\"initialVisibilities \\u5B57\\u6BB5\\u5305\\u542B\\u65E0\\u6548\\u7684\\u76EE\\u6807\\u7C7B\\u578B: \".concat(target, \"\\u3002\"));\n      }\n      if (typeof value !== 'boolean') {\n        throw new Error(\"initialVisibilities.\".concat(target, \" \\u5B57\\u6BB5\\u5FC5\\u987B\\u4E3A\\u5E03\\u5C14\\u503C\\u3002\"));\n      }\n    }\n  }\n  if (config.initialCameraProjMethod !== undefined && !['persp', 'ortho'].includes(config.initialCameraProjMethod)) {\n    throw new Error('initialCameraProjMethod 字段必须为 \"persp\" 或 \"ortho\"。');\n  }\n  if (config.initialSchleProjEnable !== undefined && typeof config.initialSchleProjEnable !== 'boolean') {\n    throw new Error('initialSchleProjEnable 字段必须为布尔值。');\n  }\n  if (!Array.isArray(config.actions) || config.actions.some(function (i) {\n    return !(i instanceof Object);\n  })) {\n    throw new Error('action 字段必须为对象列表。');\n  }\n  config.actions.forEach(function (action, index) {\n    switch (action.type) {\n      case 'rot':\n        if (typeof action.angle !== 'number') throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 angle \\u5B57\\u6BB5\\u5FC5\\u987B\\u4E3A\\u5B9E\\u6570\\u3002\"));\n        if (!(Number.isInteger(action.plane) && 0 <= action.plane && action.plane <= 5)) throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 plane \\u5B57\\u6BB5\\u5FC5\\u987B\\u4E3A\\u5927\\u4E8E\\u7B49\\u4E8E\\u96F6\\u5C0F\\u4E8E\\u516D\\u7684\\u6574\\u6570\\u3002\"));\n        if (!is4D && [2, 4, 5].includes(action.plane)) throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 plane \\u5B57\\u6BB5\\u503C \").concat(action.plane, \" \\u53EA\\u5728\\u56DB\\u7EF4\\u6A21\\u5F0F\\u53EF\\u7528\\u3002\"));\n        break;\n      case 'trans4':\n        if (!is4D) throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u53EA\\u5728\\u56DB\\u7EF4\\u6A21\\u5F0F\\u53EF\\u7528\\u3002\"));\n        if (action.ofs.length !== 4 || action.ofs.some(function (v) {\n          return typeof v !== 'number';\n        })) throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 ofs \\u5B57\\u6BB5\\u5FC5\\u987B\\u4E3A\\u56DB\\u4E2A\\u5B9E\\u6570\\u7684\\u6570\\u7EC4\\u3002\"));\n        break;\n      case 'trans3':\n        if (action.ofs.length !== 3 || action.ofs.some(function (v) {\n          return typeof v !== 'number';\n        })) throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 ofs \\u5B57\\u6BB5\\u5FC5\\u987B\\u4E3A\\u4E09\\u4E2A\\u5B9E\\u6570\\u7684\\u6570\\u7EC4\\u3002\"));\n        break;\n      case 'setVerticesEdgesDim':\n        if (typeof action.dimOfs !== 'number') throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 dimOfs \\u5B57\\u6BB5\\u5FC5\\u987B\\u4E3A\\u5B9E\\u6570\\u3002\"));\n        break;\n      case 'setProjDist':\n        if (!is4D) throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u53EA\\u5728\\u56DB\\u7EF4\\u6A21\\u5F0F\\u53EF\\u7528\\u3002\"));\n        if (typeof action.projDistOfs !== 'number') throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 projDistOfs \\u5B57\\u6BB5\\u5FC5\\u987B\\u4E3A\\u5B9E\\u6570\\u3002\"));\n        break;\n      case 'setFaceOpacity':\n        if (typeof action.faceOpacityOfs !== 'number') throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 faceOpacityOfs \\u5B57\\u6BB5\\u5FC5\\u987B\\u4E3A\\u5B9E\\u6570\\u3002\"));\n        break;\n      case 'setVisibility':\n        if (!['faces', 'wireframe', 'vertices', 'axes'].includes(action.target)) throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 target \\u5B57\\u6BB5\\u503C\\u5FC5\\u987B\\u4E3A faces\\u3001wireframe\\u3001vertices \\u6216 axes \\u4E2D\\u7684\\u4E00\\u8005\\u3002\"));\n        if (typeof action.visibility !== 'boolean') throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 visibility \\u5B57\\u6BB5\\u503C\\u5FC5\\u987B\\u4E3A boolean \\u7C7B\\u578B\\u3002\"));\n        break;\n      case 'setCameraProjMethod':\n        if (action.projMethod !== 'persp' && action.projMethod !== 'ortho') throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 projMethod \\u5B57\\u6BB5\\u503C\\u5FC5\\u987B\\u4E3A persp \\u6216 ortho \\u4E2D\\u7684\\u4E00\\u8005\\u3002\"));\n        break;\n      case 'setSchleProjEnable':\n        if (!is4D) throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u53EA\\u5728\\u56DB\\u7EF4\\u6A21\\u5F0F\\u53EF\\u7528\\u3002\"));\n        if (typeof action.enable !== 'boolean') throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684 enable \\u5B57\\u6BB5\\u503C\\u5FC5\\u987B\\u4E3A boolean \\u7C7B\\u578B\\u3002\"));\n        break;\n      default:\n        throw new Error(\"actions[\".concat(index, \"] \\u64CD\\u4F5C\\u7684\\u7C7B\\u578B \").concat(action.type, \" \\u65E0\\u6548\\u3002\"));\n    }\n    if (Object.hasOwnProperty.call(action, 'start') && Object.hasOwnProperty.call(action, 'end') && Object.hasOwnProperty.call(action, 'at')) {\n      throw new Error(\"actions[\".concat(index, \"] \\u8981\\u4E48\\u540C\\u65F6\\u62E5\\u6709 start \\u548C end \\u5B57\\u6BB5\\uFF0C\\u8981\\u4E48\\u53EA\\u62E5\\u6709 at \\u5B57\\u6BB5\\u3002\"));\n    } else if (Object.hasOwnProperty.call(action, 'start') && Object.hasOwnProperty.call(action, 'end')) {\n      if (['setVisibility', 'setCameraProjMethod', 'setSchleProjEnable'].includes(action.type)) {\n        throw new Error(\"actions[\".concat(index, \"] \\u7684 start \\u548C end \\u5B57\\u6BB5\\u503C\\u53EA\\u9002\\u7528\\u4E8E\\u4EE5\\u4E0B\\u7C7B\\u578B\\u7684\\u64CD\\u4F5C\\uFF1Arot\\u3001trans4\\u3001trans3\\u3001setVerticesEdgesDim\\u3001setProjDist\\u3001setFaceOpacity\\u3002\"));\n      }\n      if (!Number.isInteger(action.start) || !Number.isInteger(action.end) || action.end < action.start || action.start < 0 || action.end < 0) {\n        throw new Error(\"actions[\".concat(index, \"] \\u7684 start \\u548C end \\u5B57\\u6BB5\\u5FC5\\u987B\\u5747\\u4E3A\\u5927\\u4E8E\\u7B49\\u4E8E 0 \\u7684\\u6574\\u6570\\uFF0C\\u4E14 end \\u5927\\u4E8E\\u7B49\\u4E8E start\\u3002\"));\n      }\n    } else if (Object.hasOwnProperty.call(action, 'at')) {\n      if (!['setVisibility', 'setCameraProjMethod', 'setSchleProjEnable'].includes(action.type)) {\n        throw new Error(\"actions[\".concat(index, \"] \\u7684 at \\u5B57\\u6BB5\\u503C\\u53EA\\u9002\\u7528\\u4E8E\\u4EE5\\u4E0B\\u7C7B\\u578B\\u7684\\u64CD\\u4F5C\\uFF1AsetVisibility\\u3001setCameraProjMethod\\u3001setSchleProjEnable\\u3002\"));\n      }\n      if (!Number.isInteger(action.at) || action.at < 0) throw new Error(\"actions[\".concat(index, \"] \\u7684 at \\u5B57\\u6BB5\\u5FC5\\u987B\\u4E3A\\u5927\\u4E8E\\u7B49\\u4E8E 0 \\u7684\\u6574\\u6570\\u3002\"));\n    } else {\n      throw new Error(\"actions[\".concat(index, \"] \\u8981\\u4E48\\u540C\\u65F6\\u62E5\\u6709 start \\u548C end \\u5B57\\u6BB5\\uFF0C\\u8981\\u4E48\\u53EA\\u62E5\\u6709 at \\u5B57\\u6BB5\\u3002\"));\n    }\n  });\n}\n\n/**\n * 异步获取并解析用户选择的 JSON 文件。\n * @param {HTMLInputElement} fileInput - 文件输入元素。\n * @returns {Promise<object>} 返回解析后的 JSON 对象。\n */\nfunction parseJsonFileFromInput(fileInput) {\n  return new Promise(function (resolve, reject) {\n    // 确保输入元素是文件类型\n    if (fileInput.type !== 'file') {\n      reject(new Error('提供的元素不是文件输入类型。'));\n      return;\n    }\n\n    // 设置临时事件处理程序\n    fileInput.addEventListener('change', function handleChange() {\n      // 移除事件监听器，避免多次触发\n      fileInput.removeEventListener('change', handleChange);\n      if (!fileInput.files || fileInput.files.length === 0) {\n        reject(new Error('没有选择文件。'));\n        return;\n      }\n      var file = fileInput.files[0];\n      var reader = new FileReader();\n      reader.onload = function (event) {\n        try {\n          var jsonData = JSON.parse(event.target.result);\n          resolve(jsonData);\n        } catch (error) {\n          reject(new Error('文件解析失败: ' + error.message));\n        }\n      };\n      reader.onerror = function () {\n        reject(new Error('文件读取失败。'));\n      };\n      reader.readAsText(file);\n    });\n\n    // 触发文件选择对话框\n    fileInput.click();\n  });\n}\n\n\n//# sourceURL=webpack:///./src/helperFunc.js?");

/***/ }),

/***/ "./src/offProcessor.js":
/*!*****************************!*\
  !*** ./src/offProcessor.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parseOFF: () => (/* binding */ parseOFF),\n/* harmony export */   processMeshData: () => (/* binding */ processMeshData)\n/* harmony export */ });\n/* harmony import */ var poly2tri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! poly2tri */ \"./node_modules/poly2tri/src/poly2tri.js\");\n/* harmony import */ var poly2tri__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(poly2tri__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _helperFunc_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helperFunc.js */ \"./src/helperFunc.js\");\n/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type.js */ \"./src/type.js\");\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\n/**\n * 解析 OFF 格式的 3D 模型数据。\n * @param {string} data - OFF 格式的字符串数据。\n * @returns {type.Mesh3D} 包含顶点、边和面的对象。\n * @throws {Error} 当文件格式无效时抛出错误。\n */\nfunction parseOFF(data) {\n  var lines = data.split('\\n').filter(function (line) {\n    return line.trim() !== '' && !line.startsWith('#');\n  });\n  if (lines[0].trim() !== 'OFF') throw new Error('Invalid OFF file format');\n  var _lines$1$trim$split$m = lines[1].trim().split(/\\s+/).map(Number),\n    _lines$1$trim$split$m2 = _slicedToArray(_lines$1$trim$split$m, 2),\n    nVertices = _lines$1$trim$split$m2[0],\n    nFaces = _lines$1$trim$split$m2[1];\n  var vertices = [];\n  for (var i = 0; i < nVertices; i++) {\n    var _lines$trim$split$map = lines[i + 2].trim().split(/\\s+/).map(parseFloat),\n      _lines$trim$split$map2 = _slicedToArray(_lines$trim$split$map, 3),\n      x = _lines$trim$split$map2[0],\n      y = _lines$trim$split$map2[1],\n      z = _lines$trim$split$map2[2];\n    vertices.push({\n      x: x,\n      y: y,\n      z: z\n    });\n  }\n  var faces = [];\n  for (var _i = 0; _i < nFaces; _i++) {\n    var parts = lines[_i + 2 + nVertices].trim().split(/\\s+/);\n    var count = parseInt(parts[0]);\n    faces.push(parts.slice(1, count + 1).map(Number));\n  }\n  var edges = (0,_helperFunc_js__WEBPACK_IMPORTED_MODULE_1__.getUniqueSortedPairs)(faces).map(function (edge) {\n    return edge.map(function (index) {\n      return vertices[index];\n    });\n  });\n  return {\n    vertices: vertices,\n    faces: faces,\n    edges: edges\n  };\n}\n\n/**\n * 处理网格数据，包括顶点和面的三角化。\n * @param {type.NonTriMesh3D} meshData - 网格数据对象。\n * @param {import('lodash').Function2<number, number, any>} progressCallback - 处理面时每隔 200ms 执行的回调。\n * @returns {type.Mesh3D} 处理后的网格数据。\n */\nfunction processMeshData(_ref, progressCallback) {\n  var vertices = _ref.vertices,\n    faces = _ref.faces,\n    edges = _ref.edges;\n  var processedVertices = _toConsumableArray(vertices);\n  var processedFaces = [];\n  var totalItems = faces.length;\n  var processedItems = 0;\n  var prevPostTime = performance.now();\n  faces.forEach(function (face) {\n    /**\n     * 三角剖分单个面。\n     * @param {Array<type.Point3D>} vertices3D - 顶点数组。\n     * @returns {Array<[number, number, number]>} - 三角剖分出来的三角形。\n     */\n    function triangulateFace(vertices3D) {\n      if (vertices3D.length === 3) return [face];\n      var _rotateToXY = (0,_helperFunc_js__WEBPACK_IMPORTED_MODULE_1__.rotateToXY)(vertices3D),\n        rotated = _rotateToXY.rotated,\n        theta = _rotateToXY.theta,\n        phi = _rotateToXY.phi,\n        z = _rotateToXY.z;\n      var contour = rotated.map(function (p) {\n        return new (poly2tri__WEBPACK_IMPORTED_MODULE_0___default().Point)(p.x, p.y);\n      });\n      var triangles = [];\n      var decomposed = (0,_helperFunc_js__WEBPACK_IMPORTED_MODULE_1__.decomposeSelfIntersectingPolygon)(contour);\n      var _iterator = _createForOfIteratorHelper(decomposed),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var subPolygon = _step.value;\n          var swctx = new (poly2tri__WEBPACK_IMPORTED_MODULE_0___default().SweepContext)(subPolygon);\n          swctx.triangulate();\n          var subTriangles = swctx.getTriangles().map(function (triangle) {\n            return triangle.getPoints().map(function (pt) {\n              pt.z = z;\n              var origPoint = (0,_helperFunc_js__WEBPACK_IMPORTED_MODULE_1__.inverseRotatePoint)(pt, theta, phi);\n              var origIndex = processedVertices.findIndex(function (p) {\n                return (0,_helperFunc_js__WEBPACK_IMPORTED_MODULE_1__.arePointsClose)(p, origPoint);\n              });\n              if (origIndex > -1) return origIndex;\n              processedVertices.push(origPoint);\n              return processedVertices.length - 1;\n            });\n          });\n          triangles.push.apply(triangles, _toConsumableArray(subTriangles));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return triangles;\n    }\n    var faceVertices = face.map(function (idx) {\n      return vertices[idx];\n    });\n    var triangles = triangulateFace(faceVertices);\n    triangles.forEach(function (t) {\n      return processedFaces.push(t);\n    });\n    processedItems++;\n    // 每隔 200ms 发送一次进度。\n    if (progressCallback && performance.now() - prevPostTime >= 200) {\n      prevPostTime = performance.now();\n      progressCallback(processedItems, totalItems);\n    }\n  });\n  return {\n    vertices: processedVertices,\n    faces: processedFaces,\n    edges: edges\n  };\n}\n\n\n//# sourceURL=webpack:///./src/offProcessor.js?");

/***/ }),

/***/ "./src/offProcessor4D.js":
/*!*******************************!*\
  !*** ./src/offProcessor4D.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   parse4OFF: () => (/* binding */ parse4OFF),\n/* harmony export */   process4DMeshData: () => (/* binding */ process4DMeshData)\n/* harmony export */ });\n/* harmony import */ var _helperFunc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helperFunc.js */ \"./src/helperFunc.js\");\n/* harmony import */ var poly2tri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! poly2tri */ \"./node_modules/poly2tri/src/poly2tri.js\");\n/* harmony import */ var poly2tri__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(poly2tri__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _type_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./type.js */ \"./src/type.js\");\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t[\"return\"] || t[\"return\"](); } finally { if (u) throw o; } } }; }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\n\n\n\n\n/**\n * 解析 4OFF 格式的四维网格数据。\n * @param {string} data - 4OFF 格式的字符串数据。\n * @returns {type.NonTriMesh4D} 包含顶点、面、边和胞的对象。\n * @throws {Error} 当文件格式无效时抛出错误。\n */\nfunction parse4OFF(data) {\n  var lines = data.split('\\n').filter(function (line) {\n    return line.trim() !== '' && !line.startsWith('#');\n  });\n  if (lines[0].trim() !== '4OFF') throw new Error('Invalid 4OFF file format');\n  var _lines$1$trim$split$m = lines[1].trim().split(/\\s+/).map(Number),\n    _lines$1$trim$split$m2 = _slicedToArray(_lines$1$trim$split$m, 4),\n    nVertices = _lines$1$trim$split$m2[0],\n    nFaces = _lines$1$trim$split$m2[1],\n    nCells = _lines$1$trim$split$m2[3];\n  var vertices = [];\n  for (var i = 0; i < nVertices; i++) {\n    var _lines$trim$split$map = lines[i + 2].trim().split(/\\s+/).map(parseFloat),\n      _lines$trim$split$map2 = _slicedToArray(_lines$trim$split$map, 4),\n      x = _lines$trim$split$map2[0],\n      y = _lines$trim$split$map2[1],\n      z = _lines$trim$split$map2[2],\n      w = _lines$trim$split$map2[3];\n    vertices.push({\n      x: x,\n      y: y,\n      z: z,\n      w: w\n    });\n  }\n  var faces = [];\n  for (var _i = 0; _i < nFaces; _i++) {\n    var parts = lines[_i + 2 + nVertices].trim().split(/\\s+/);\n    var count = parseInt(parts[0]);\n    faces.push(parts.slice(1, count + 1).map(Number));\n  }\n  var cells = [];\n  for (var _i2 = 0; _i2 < nCells; _i2++) {\n    var _parts = lines[_i2 + 2 + nVertices + nFaces].trim().split(/\\s+/);\n    var _count = parseInt(_parts[0]);\n    cells.push(_parts.slice(1, _count + 1).map(Number));\n  }\n  var edges = (0,_helperFunc_js__WEBPACK_IMPORTED_MODULE_0__.getUniqueSortedPairs)(faces).map(function (edge) {\n    return edge.map(function (index) {\n      return vertices[index];\n    });\n  });\n  return {\n    vertices: vertices,\n    faces: faces,\n    edges: edges,\n    cells: cells\n  };\n}\n\n/**\n * 处理四维网格数据，包括面的三角化和胞重构。\n * @param {type.NonTriMesh4D} data - 四维网格数据对象。\n * @param {import('lodash').Function2<number, number, any>} progressCallback - 处理面时每隔 200ms 执行的回调。\n * @returns {type.Mesh4D} 处理后的网格数据，包含新增顶点、三角化面片、边和重构胞。\n */\nfunction process4DMeshData(_ref, progressCallback) {\n  var vertices = _ref.vertices,\n    faces = _ref.faces,\n    edges = _ref.edges,\n    cells = _ref.cells;\n  var processedVertices = _toConsumableArray(vertices);\n  var processedFaces = [];\n  var processedCells = [];\n  var totalItems = faces.length;\n  var processedItems = 0;\n  var prevPostTime = performance.now();\n  var facesMap = {};\n  faces.forEach(function (face, faceIndex) {\n    /**\n     * 三角剖分单个面。\n     * @param {Array<type.Point4D>} vertices4D - 顶点数组。\n     * @returns {Array<[number, number, number]>} - 三角剖分出来的三角形。\n     */\n    function triangulateFace(vertices4D) {\n      if (vertices4D.length === 3) return [face];\n      var _rotate4DPointsToXY = (0,_helperFunc_js__WEBPACK_IMPORTED_MODULE_0__.rotate4DPointsToXY)(vertices4D),\n        rotated = _rotate4DPointsToXY.rotated,\n        rotationMatrix = _rotate4DPointsToXY.rotationMatrix,\n        z = _rotate4DPointsToXY.z,\n        w = _rotate4DPointsToXY.w;\n      var contour = rotated.map(function (p) {\n        return new poly2tri__WEBPACK_IMPORTED_MODULE_1__.Point(p.x, p.y);\n      });\n      var triangles = [];\n      var decomposed = (0,_helperFunc_js__WEBPACK_IMPORTED_MODULE_0__.decomposeSelfIntersectingPolygon)(contour);\n      var _iterator = _createForOfIteratorHelper(decomposed),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var subPolygon = _step.value;\n          var swctx = new poly2tri__WEBPACK_IMPORTED_MODULE_1__.SweepContext(subPolygon);\n          swctx.triangulate();\n          var subTriangles = swctx.getTriangles().map(function (triangle) {\n            return triangle.getPoints().map(function (pt) {\n              pt.z = z;\n              pt.w = w;\n              var origPoint = (0,_helperFunc_js__WEBPACK_IMPORTED_MODULE_0__.apply4DInverseRotation)(pt, rotationMatrix);\n              var origIndex = processedVertices.findIndex(function (p) {\n                return (0,_helperFunc_js__WEBPACK_IMPORTED_MODULE_0__.are4DPointsClose)(p, origPoint);\n              });\n              if (origIndex > -1) return origIndex;\n              processedVertices.push(origPoint);\n              return processedVertices.length - 1;\n            });\n          });\n          triangles.push.apply(triangles, _toConsumableArray(subTriangles));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return triangles;\n    }\n    var trianglesForFaceStartIndex = processedFaces.length;\n    var faceVertices = face.map(function (idx) {\n      return vertices[idx];\n    });\n    var triangles = triangulateFace(faceVertices);\n    triangles.forEach(function (t) {\n      return processedFaces.push(t);\n    });\n    var trianglesForFaceEndIndex = processedFaces.length - 1;\n    facesMap[faceIndex] = [trianglesForFaceStartIndex, trianglesForFaceEndIndex];\n    processedItems++;\n    // 每隔 200ms 发送一次进度。\n    if (progressCallback && performance.now() - prevPostTime >= 200) {\n      prevPostTime = performance.now();\n      progressCallback(processedItems, totalItems);\n    }\n  });\n  var _iterator2 = _createForOfIteratorHelper(cells),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var cell = _step2.value;\n      var processedCell = [];\n      var _iterator3 = _createForOfIteratorHelper(cell),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var face = _step3.value;\n          processedCell.push.apply(processedCell, _toConsumableArray(_helperFunc_js__WEBPACK_IMPORTED_MODULE_0__.range.apply(void 0, _toConsumableArray(facesMap[face]))));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      processedCells.push(processedCell);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return {\n    vertices: processedVertices,\n    faces: processedFaces,\n    edges: edges,\n    cells: processedCells\n  };\n}\n\n\n//# sourceURL=webpack:///./src/offProcessor4D.js?");

/***/ }),

/***/ "./src/type.js":
/*!*********************!*\
  !*** ./src/type.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Edge3D: () => (/* binding */ Edge3D),\n/* harmony export */   Edge4D: () => (/* binding */ Edge4D),\n/* harmony export */   Mesh3D: () => (/* binding */ Mesh3D),\n/* harmony export */   Mesh4D: () => (/* binding */ Mesh4D),\n/* harmony export */   NonTriMesh3D: () => (/* binding */ NonTriMesh3D),\n/* harmony export */   NonTriMesh4D: () => (/* binding */ NonTriMesh4D),\n/* harmony export */   Point3D: () => (/* binding */ Point3D),\n/* harmony export */   Point4D: () => (/* binding */ Point4D),\n/* harmony export */   RotationMatrix: () => (/* binding */ RotationMatrix)\n/* harmony export */ });\n/**\n * 三维点。\n * @typedef {object} Point3D\n * @property {number} x - x 坐标。\n * @property {number} y - y 坐标。\n * @property {number} z - z 坐标。\n */\n\n/**\n * 四维点。\n * @typedef {object} Point4D\n * @property {number} x - x 坐标。\n * @property {number} y - y 坐标。\n * @property {number} z - z 坐标。\n * @property {number} w - w 坐标。\n */\n\n/**\n * 三维边。\n * @typedef {[Point3D, Point3D]} Edge3D\n */\n\n/**\n * 四维边。\n * @typedef {[Point4D, Point4D]} Edge4D\n */\n\n/**\n * 非三角三维网格数据。\n * @typedef {object} NonTriMesh3D\n * @property {Array<Point3D>} vertices - 顶点数组。\n * @property {Array<Array<number>>} faces - 面索引数组。\n * @property {Array<[number, number]>} edges - 边索引数组。\n */\n\n/**\n * 非三角四维网格数据。\n * @typedef {object} NonTriMesh4D\n * @property {Array<Point4D>} vertices - 顶点数组。\n * @property {Array<Array<number>>} faces - 面索引数组。\n * @property {Array<[number, number]>} edges - 边索引数组。\n * @property {Array<Array<number>>} cells - 胞索引数组。\n */\n\n/**\n * 三维网格数据。\n * @typedef {object} Mesh3D\n * @property {Array<Point3D>} vertices - 顶点数组。\n * @property {Array<[number, number, number]>} faces - 面索引数组，必须是三角形面。\n * @property {Array<[number, number]>} edges - 边索引数组。\n */\n\n/**\n * 四维网格数据。\n * @typedef {object} Mesh4D\n * @property {Array<Point4D>} vertices - 顶点数组。\n * @property {Array<[number, number, number]>} faces - 面索引数组，必须是三角形面。\n * @property {Array<[number, number]>} edges - 边索引数组。\n * @property {Array<Array<number>>} cells - 胞索引数组。\n */\n\n/**\n * 4D 旋转矩阵。\n * @typedef {[[number, number, number, number], [number, number, number, number], [number, number, number, number], [number, number, number, number]]} RotationMatrix\n */\n\nvar Point3D = {};\nvar Point4D = {};\nvar Edge3D = {};\nvar Edge4D = {};\nvar NonTriMesh3D = {};\nvar NonTriMesh4D = {};\nvar Mesh3D = {};\nvar Mesh4D = {};\nvar RotationMatrix = {};\n\n//# sourceURL=webpack:///./src/type.js?");

/***/ })

}]);